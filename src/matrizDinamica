#ifndef MATRIZ_H_
#define MATRIZ_H_
#include <iostream>

typedef unsigned int ui;

template<class T>
class Terreno{
private:
	ui cantidadFilas;
	ui cantidadColumnas;
	T** terreno;
public:
	//Constructor
	/*
	 * post: Inicializa el Terreno en 0 filas y 0 columnas
	 */
	Terreno();
	/*
	 * post: Crea el Terreno con el tamaño ingresado
	 */
	void definirTamanio(ui filas, ui columnas);
	/*
	 * pre: Dato debe ser un valor de tipo T, 1<=fila<=cantidadFilas y 1<=columna<=cantidadColumnas
	 * post: Asigna el dato en la posicion (fila, columna)
	 */
	void asignarDato(T dato, ui fila, ui columna);
	/*
	 * pre: 1<=fila<=cantidadFilas y 1<=columna<=cantidadColumnas
	 * post: Devuelve el dato que se encuentra en la posicion (fila, columna)
	 */
	T obtenerDato(ui fila, ui columna);
	/*
	 * post: Tanto menor fila como menor columna devuelven el menor valor de filas/columnas, que puede ser
	 * o cantidadFilas/cantidadColumnas o filaNueva/columnaNueva
	 */
	ui menorFila(ui filaNueva);
	ui menorColumna(ui columnaNueva);
	/*
	 * post: Copia los datos del terreno anterior en el nuevo llamada dato de dimension (fila, columna)
	 */
	void copiar(T** dato, ui fila, ui columna);
	/*
	 * post: Modifica el terreno con el nuevo tamaño (fila, columna)
	 */
	void asignarTamanio(ui fila, ui columna);
	//Destructor
	/*
	 * post: Libera la memoria o recursos pedidos
	 */
	~Terreno();

};
#endif /* MATRIZ_H_ */

template<class T>
Terreno<T>::Terreno()
{
	cantidadFilas=0;
	cantidadColumnas=0;
	terreno=0;
}

template<class T>
void Terreno<T>::definirTamanio(ui filas, ui columnas)
{
	if((filas>0) && (columnas>0))
	{
		terreno=new T*[filas];
		for(ui i=0; i<filas; i++)
			terreno[i]=new T[columnas];//Reservo memoria para las filas y las columnas

		cantidadFilas=filas;
		cantidadColumnas=columnas;
	}
	else
		throw "Tamaño inválido";
}

template<class T>
void Terreno<T>::asignarDato(T dato, ui fila, ui columna)
{
	if ((fila>cantidadFilas) || (columna>cantidadColumnas))
			throw "Posición inválida";

	*(*(terreno+fila)+columna)=dato; //terreno[fila][columna]=dato;
}

template<class T>
T Terreno<T>::obtenerDato(ui fila, ui columna)
{
	if ((fila>cantidadFilas) || (columna>cantidadColumnas))
			throw "Posición inválida";

	T dato=*(*(terreno+fila)+columna);
	return dato;
}

template<class T>
ui Terreno<T>::menorFila(ui filaNueva)
{
	if(filaNueva<cantidadFilas)
		return filaNueva;
	else
		return cantidadFilas;
}

template<class T>
ui Terreno<T>::menorColumna(ui columnaNueva)
{
	if(columnaNueva<cantidadColumnas)
		return columnaNueva;
	else
		return cantidadColumnas;
}

template<class T>
void Terreno<T>::copiar(T** dato, ui fila, ui columna)
{
	ui menorF=menorFila(fila);
	ui menorC=menorColumna(columna);

	for (ui i=0; i<menorF; i++)
		for(ui j=0; j<menorC; j++)
		{
			*(*(dato+i)+j) = *(*(terreno+i)+j);
		}
}

template<class T>
void Terreno<T>::asignarTamanio(ui fila, ui columna)
{
	T** aux=new T*[fila];
	for(ui i=0; i<fila; i++)
		aux[i]=new T[columna];

	if ((cantidadFilas>0) || (cantidadColumnas>0))
	{
		copiar(aux,fila,columna);
		for(ui i=0; i<fila; i++)
		{
			delete[] terreno[i];
		}
		delete[] terreno;
	}
	terreno=aux;
	cantidadFilas=fila;
	cantidadColumnas=columna;
}

template<class T>
Terreno<T>::~Terreno()
{
	if ((cantidadFilas>0) || (cantidadColumnas>0))
	{
		for(ui i=0; i<cantidadFilas; i++)
		{
			delete[] terreno[i];
		}
		delete[] terreno;
	}
}